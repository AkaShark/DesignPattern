# 抽象工厂模式

### 背景故事

一个项目最开始底层支持的数据是SQLServer但是后面需要改动为Access，我们必须要把所有设计到底层数据的地方支持都修改，如果后面发生了修改还需要修改两个地方，或者增加新的底层支持后我们又要去修改，copy出第三份，这将是一场灾难呀。。。可以使用工厂方法模式，但是有一个问题就是系统中一定是不止一张表的，这就需要我们在工厂类中添加多个创建对应具体产品的类，我们可以将这些工厂公共部分抽离，这也就形成了抽象工厂如下图所示的样子

&#x20;![](https://img-blog.csdnimg.cn/img\_convert/3405feb0f58e89fb2b14fdf6ddd2a3d1.png)&#x20;

创建抽象工厂，抽象产品，具体工厂，具体产品, IUser, IDepartment用于与客户端访问，解除与具体数据库访问的耦合，同时由于多态性，具体产品也是在子类中初始化，增加新的数据库支持变得更加方便.

![](https://img-blog.csdnimg.cn/img\_convert/f0e0127cc86c61b8e5fda22d66de01a9.png)

AbstractProductA和AbstractProductB是两个抽象产品，ProductA1,ProductA2,和ProductB1, ProductB2就是对两个抽象产品的具体分类的实现

抽象工厂是拥有一个抽象工厂类和一些列的抽象产品类，最大的好处便是易于交换产品锡类，由于具体工厂类在一个应用中需要初始化的时候出现一次，这就使得改变一个应用变得十分简单，他只需要改变具体工厂即可使用不同的产品配置。同时他让具体的创建实例过程与客户端分离，客户端通过他们的抽象接口操作实例，产品的具体类名被具体工厂的实现分离，不会出现在客户端代码中。

但是在新增加一个产品表的时候，我们需要抽象工厂增加新的接口已经实现抽象接口的工厂类这样的修改比较大应该如何来优化下呢，还有就是在修改底层数据库支持的时候，需要修改没出初始化工厂的地方这也将是不小的改动。

### 使用简单工厂来改进抽象工厂

去除IFactory SqlserverFactory AccessFactory三个工厂，而取而代之使用DataAcces类，用一个简单工厂模式来实现

&#x20;![](https://img-blog.csdnimg.cn/img\_convert/bb9e1c3e4b1960506a52dea5a8ff0af8.png)

这样我们可以减少修改的范围，同时我们可以使用反射+配置文件动态的需要的类来减少修改。

### 模式动机

* 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。
  * 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
  * 产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。
* 当系统锁提供的工厂所需要生产的集体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式
* 抽象工厂模式是所有形式的工厂模式中最为抽象和最具有一般性的一种形态
* 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建，当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品组中的所有对象时，抽象工厂模式比工厂方法模式更为简单有效率

可以理解为抽象工厂为一个海尔或者格力的工厂可以创建出海尔的一些列产品或者格力的，而工厂方法中创建的就是一个具体的产品海尔电视或者格力电视. **创建产品族**

### 模式定义

抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

### 模式结构

包含如下角色

* AbstractFactory 抽象工厂
* ConcreteFactory 具体工厂
* AbstractFactory 抽象产品
* Product 具体产品

&#x20;![](https://img-blog.csdnimg.cn/img\_convert/f0e0127cc86c61b8e5fda22d66de01a9.png) ![](https://img-blog.csdnimg.cn/img\_convert/d6a73c5549c2ec717a0e506f4f6f20fb.png)

### 模式优点

* 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
* 当一个产品族中的多个对象被设置成一起工作是，他能保证客户端始终只使用同一个船票族中的对象，这对一些需要根据当前环境来决定其行为的软件系统来说，是一种十分实用的设计模式
* 增加新的具体工厂和产品族很方便，无需修改已有的系统符合开闭原则

### 模式缺点

* 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
* 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

### 适用环境

* 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
* 系统中有多于一个的产品族，而每次只使用其中某一产品族。(底层数据库的使用)
* 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
* 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

### 模式应用

在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。(每一种不同的背景颜色是一个族且系统要求控件同时被使用，对应着有不同颜色的不同控件的具体产品和不同控件的抽象产品)

### 模式拓展

“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面

* 增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。
* 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。(在抽象工厂中添加新的结构)

抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产 品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便

* 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。

### 总结

* 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。
* 抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。
* 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。
* 抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。
* 抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 体实现。
