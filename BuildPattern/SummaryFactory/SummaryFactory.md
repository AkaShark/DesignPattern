# 工厂模式总结

### 介绍

工厂三姐妹

* 简单工厂模式 (小妹)
* 工厂方法模式 (二姐)
* 抽象工厂模式 (大姐)

### 简单工厂模式

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类(简单工厂类)来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 **简单工厂的核心在于工厂类中Switch case创建不同的实例** 由一下几个部分组成:

* Factory: 工厂角色 工厂角色负责实现创建所有实例的内部逻辑
* Product: 抽象产品角色 (返回的实例继承的父类) 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
* ConcreteProduct: 具体的产品角色 (返回的具体子类) 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

![](https://img-blog.csdnimg.cn/img\_convert/ec9839435a9c4827da8b08b7d9214d59.png)

将产品的创建过程和产品的使用分开，达到松耦合的目的，但是简单工厂模式由于工厂类的职责过重导致添加新的产品必须要去修改工厂类，这并不符合开闭原则。

#### 优点

* 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
* 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
* 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

#### 缺点

* 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
* 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
* 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。（工厂承担了太多的职责）
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到其子类实现(工厂的子类)

工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，**工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象**，这样做的目的是将**产品类的实例化操作延迟到工厂子类中完成**，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

工厂方法模式包含如下角色:

* product 抽象产品
* ConcreteProduct 具体产品
* Factory 抽象工厂
* ConcreteFactory 具体工厂

![](https://img-blog.csdnimg.cn/img\_convert/f845aba492ec1d2d5e08858bbd4af31b.png)&#x20;

**工厂方法中将产品类的实例化的过程延迟到工厂子类中实现，每个具体的产品对应一个具体工厂(工厂子类)**

相比较于简单工厂模式，工厂方法模式将变化的工厂类添加了一层抽象(减少了简单工厂模式中工厂类的职责)，将工厂的公共部分抽象为工厂父类，然后具体的工厂继承这个父类并且实现创建具体产品.

#### 优点

* 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户端隐藏了哪中具体产品类被实例化这一细节，用户只需要关心所需产品对应的工厂，无需关心创建细节，甚至无须知道具体产品类的类名
* 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键，他能够使得工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装到具体工厂内部，工厂方法模式之所以又称为多态工厂模式，是因为所有的具体工厂类都具有统一的抽象父类
* 使用工厂方法模式的另一个优点是咋系统中加入新产品时，无需修改抽象工厂和抽象产品提供的接口，而只需要添加一个具体工厂和具体产品就可以了，完全符合开闭原则

#### 缺点

* 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销
* 由于考虑到系统的可扩展行，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，而且在是现实可能需要用到反射等技术，增加了系统的实现难度

### 抽象工厂模式

抽象工厂模式 提供**一个创建一系列**(抽象工厂类)相关或相互依赖对象的接口，而无需指定他们具体的类

抽象工厂是由一下几个部分组成的:

* AbstractFactory 抽象工厂
* ConcreteFactory 具体工厂
* AbstractFactory 抽象产品
* Product 具体产品

![](https://img-blog.csdnimg.cn/img\_convert/b90d412e2e5e9e45decf5aca944624d0.png)&#x20;

**抽象工厂模式和工厂方法模式很相似，只不过抽象工厂模式的工厂可以创建一系列的产品，这是工厂方法所不能达到的** 可以理解为格力工厂和美的工厂，格力工厂可以生产格力电视，格力空调等等

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建，当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品组中的所有对象时，抽象工厂模式比工厂方法模式更为简单有效率(可以创建一个产品组中的所有对象)

#### 优点

* 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
* 当一个产品族中的多个对象被设置成一起工作是，他能保证客户端始终只使用同一个船票族中的对象，这对一些需要根据当前环境来决定其行为的软件系统来说，是一种十分实用的设计模式
* 增加新的具体工厂和产品族很方便，无需修改已有的系统符合开闭原则

#### 缺点

* 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
* 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

### 总结

工厂模式将产品的创建和产品的使用分离，解耦，这样客户端不需要关注产品创建过程的一些细节，体现了封装性，在简单工厂中因为工厂类的职责过大导致不符合开闭原则，工厂方法解决了这个问题，通过将变化的工厂类继续抽象，抽象了一个工厂基类，将具体的产品的实例化的过程延迟到工厂子类中，但是工厂方法中的工厂只能创建单一的产品，这和现实并不符合，比如格力工厂不但可以生产格力空调，也可以生产格力洗衣机等等，于是在抽象工厂方法中，面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建，当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品组中的所有对象，抽象工厂模式比工厂方法模式更为简单有效率(可以创建一个产品组中的所有对象) 这就是建造模式中的三个工厂模式的简单介绍。
